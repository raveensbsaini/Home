# 2024-04-02 (Review)
## head.py
- [random trivia] reference `head` command has a default of initial 10 lines. And you can use `-n` to change that.
  ```bash
  head somefile.txt # prints 10 lines
  head -n 100 somefile.txt # prints 100 lines
  # or similarly
  head --lines 100 somefile.txt # prints 100 lines
  ```
  - In CLI tools `-n` or `--lines` are known as `flags` (kind of like named arguments in python). And argument without any name are known as `positional`. Similar to python, `flags` should be used for optional values, i.e. user doesn't need to provide them, but he can. While `positional` values are generally required. This is not a fixed rule, since `grep` and `head` allow `positional` argument to be optional (it'll read stdin if argument not provided).

## grep.py
- good job!
- [bug:optional] CLI tools should be easy to chain (like: `command1 | command2 ... | command3`). Adding an extra line makes it weird. For example:
  ```
  # Here using original `grep`, we won't see any output. But using your `grep` we see two lines.
  echo "123" | python3 grep.py 3 | python3 grep.py "made"
  ```

- [codestyle] You have duplicated code for `file` and `stdin` implementation, it can easily be de-duplicated since `stdin` is also a file.
  ```python3
  # Instead of 
  if stdin:
    for line in stdin:
      ...
      ...
      ...

  else:
    file = open('...')
    for line in file: # Notice that this loop is same as the `stdin` one
      ...
      ...
      ...
  ```

  We can do
  ```python3
  if stdin:
    file = stdin
  else:
    file = open("...")

  for line in stdin:
      ...
      ...
      ...

  ```




# 2024-03-25 (Review)
- Messages marked as `bug:optional` are serious issues but not required to be fixed, you can ignore them.
- Messages marked as `bug` are serious issues and needs to be fixed.
- All other messages are just informational. No action required, but if you want to use these feel free to do so.

## cat.py

1. [bug:optional]: It prints extra empty line between all lines. Try `python3 cat.py tee.py` to see what I mean, there will be extra empty lines, which are not present in `tee.py`.

2. [random trivia]: Windows and Linux represent newline differently, windows uses `\r\n` and linux uses only `\n`, so a robuse `cat` implementation will take this into acount and will preseve the `\r\n` correctly if present. We _don't_ need to handle this. 

3. [useful stuff]: See `pathlib` module in python. It is handy for dealing with file and folder paths in python. 
  ```python3
  # An example
  from pathlib import Path

  file = Path("/some/folder") / 'tee.py'

  # NOTE that your code is more resource efficient than this. This will load the whole file in memory,
  # so if you are trying to print a 12GB file on system with 8GB ram, this code will not work, but your code will.
  content = file.read_text()
  file.write_text('some text')

  # or
  content_in_bytes = file.read_bytes()
  ```

4. [useful stuff]: See `argparse` module in python. It is handy for dealing with arguments in python i.e. it can automatically generate `--help`, error messages etc. I am attaching an example generated by `gemini` AI below.
  ```python3
  # Usage
  # python add.py 5 3
  # python add.py --help
  # python add.py 3 # this will be an error

  import argparse

  # Create an ArgumentParser object
  parser = argparse.ArgumentParser(description="Add two numbers")

  # Add an argument for the first number
  parser.add_argument("first_number", type=int, help="The first number to add")

  # Add an argument for the second number
  parser.add_argument("second_number", type=int, help="The second number to add")

  # Parse the arguments from the command line
  args = parser.parse_args()

  # Add the two numbers and print the result
  result = args.first_number + args.second_number
  print(f"The sum of {args.first_number} and {args.second_number} is {result}")
  ```

## ls.py
- Okay.


## tee.py
- [bug]: This is not actually doing what the real `tee` does. `tee` takes the message from stdin not as an argument. `tee` is to be used like this. 
  ```
  # Store the output of `python3 my_command.py` into xyz.txt and also print on terminal
  python3 my_command.py | tee xyz.txt
  ```

## head.py
- [bug]: 
```sh
# Prints starting lines of some_file using following syntax
cat some_file | head
```

## tail.py
- Same issue as head

